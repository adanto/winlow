# Part 4 – Fuzzing & Exploit Dev

**What this chapter covers**

* How to pick and instrument Windows targets (file parsers, RPC/ALPC, COM, services, drivers) for coverage-guided fuzzing
* Building stable, crash-rich harnesses on x64 with proper ABI, persistent loops, and exception fences
* Corpus strategy (seeding, mutation, generation, grammar/state machines), minimization, and deduplication
* Crash triage on Windows: buckets, reliable repro, and turning a crash into a memory-safety primitive
* Practical knobs: PageHeap, AppVerifier, ASan/Clang, WinAFL/TinyInst/DynamoRIO, ETW, and Minidump pipelines

## Core concepts

### Fuzzing, Windows edition (one realistic shape)

A coverage-guided fuzzer mutates inputs, feeds a target function, and prefers inputs that **increase coverage**—measured as new basic blocks or edges executed. On Windows, you usually **don’t fuzz the whole EXE**; you write a **harness** that calls a hot parser or RPC stub in-process, then run an engine (WinAFL, libFuzzer-compat, TinyInst) that instruments coverage and drives the harness.

```c
// Minimal, persistent file-parser harness for coverage-guided fuzzing on Windows (x64).
// cl /O2 /MD /Zi harness.c targetlib.lib
#include <windows.h>
#include <stdio.h>

__declspec(noinline)
int TargetParse(const uint8_t* data, size_t size); // your target API, exported from the library

static LONG WINAPI VehFilter(EXCEPTION_POINTERS* p)
{
    // swallow AVs and report to the fuzzer; return EXCEPTION_EXECUTE_HANDLER to keep the loop alive
    return EXCEPTION_EXECUTE_HANDLER;
}

int main(void)
{
    SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
    AddVectoredExceptionHandler(1, VehFilter);

    // persistent mode: fuzzer injects new testcases into this shared buffer
    static uint8_t buf[1<<20]; // 1MB max testcase
    for (;;)
    {
        DWORD need = 0;
        if (!ReadFile(GetStdHandle(STDIN_FILENO), buf, sizeof(buf), &need, NULL))
            break;

        __try {
            (void)TargetParse(buf, need);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            // crash was handled by VEH; continue to next testcase
        }
        // Reset allocator state if the target holds globals or caches
        // e.g., target_reset(); or CoTaskMemFree caches, etc.
    }
    return 0;
}
```

*Why this works:* a **persistent loop** amortizes process start-up; **VEH** (Vectored Exception Handler) keeps the loop alive while still letting the engine capture the crash; and reading from `stdin` plays nicely with engines that pipe inputs. If you’re using **WinAFL** with DynamoRIO/TinyInst, this is the shape it expects.

---

### Choosing targets that move needles

Not all Windows code fuzzes equally well. Prioritize:

* **File & media parsers**: PE/COFF, image formats, document filters, font engines, codecs, Windows shell metadata (property handlers).
* **Network & RPC**: WinRM/SMB sub-protocols, custom RPC servers (ALPC-backed services), DCOM/COM activation parameters.
* **Configuration & interpreters**: PowerShell AST transforms, XAML/JS engines in host apps, installers/MSI custom actions.
* **Kernel/driver IOCTL**: exposed device objects with rich control buffers; requires kernel harnessing and safety nets.

Ask: *does the target parse **untrusted data** and run in a privileged or high-value context?* If yes, invest.

---

### Coverage and the Windows toolbox

On Linux you reach for sanitizers and built-in coverage. On Windows you can still get high-quality signals:

* **WinAFL + DynamoRIO / TinyInst**: instruments basic-block/edge coverage without recompiling the target.
* **Clang-cl Sanitizer Coverage + ASan**: modern toolchains support sancov and AddressSanitizer on Windows for user-mode code; fast and precise if you can rebuild.
* **ETW**: not coverage, but superb for *effects* when triaging repro (file/registry/network operations).
* **PageHeap / AppVerifier**: catches heap misuse ahead of time; slower but increases *meaningful* crash density.

Coverage is the **compass**; sanitizers and verifier knobs are the **landmines** you plant to turn undefined behavior into reproducible failures.

---

### Mutation vs. generation vs. grammar

* **Mutation-based**: start from real samples, flip/splice/arith-mutate bytes. Fastest path to shallow bugs; relies on a good seed corpus.
* **Generation-based**: produce inputs from format specs (e.g., Peach Pit, ANTLR grammar). Reaches deeper states if your spec is decent.
* **Grammar/stateful fuzzing**: orchestrate valid sequences (RPC calls, COM method orders, protocol handshakes). For ALPC/RPC/COM, state matters more than bytes.

On Windows, **stateful fuzzing** pays off: many bugs hide behind “init → negotiate → allocate → send payload” rather than in a first packet.

---

### Make crashing deterministic

Heisenbugs make triage awful. Stabilize:

* **Single-thread** the harness, or gate entry with a lock.
* Fix environment: temp paths, locale, code page, DPI, `%PATH%`, `%USERPROFILE%`.
* **Disable background updates**/telemetry in the VM.
* Provide deterministic time (fake `GetTickCount64` in harness) if the target uses timeouts.

Then you can bucket by exact exception and top-of-stack, reproduce, and move toward exploitability.

---

### From crash to primitive

A crash is only “interesting” if it can produce a memory-safety primitive (write/read/PC control). Your path:

1. **First-fault fidelity**: ensure you’re looking at the *first* invalid access—turn on PageHeap/Guard Pages to catch earlier bounds issues.
2. **Classify**: stack vs heap, UAF vs OOB, type confusion vs arithmetic.
3. **Constrain**: is content **attacker-controlled**? Prove it with pattern bytes (`0x41` sequences) in the dereferenced region.
4. **Mitigation check**: does `/GS` fire? Does CFG/CET stop the indirect call? Document constraints for exploit dev.
5. **Minimize**: shrink the testcase to isolate the smallest reproducer—your future exploit grammar.

---

### State machines: RPC, COM, and ALPC

Fuzzing a single entry point is not enough if the program needs a handshake.

* **RPC**: create a binding to the endpoint (named pipe, TCP), then send a sequence of `opnums` with argument structures.
* **COM**: instantiate (`CoCreateInstance`), set properties, call methods; sometimes **marshal/unmarshal** across apartments.
* **ALPC**: often internal; instead, find the **RPC server** sitting on ALPC and drive it via user-mode RPC stubs.

In each case, build a harness that **validates server liveness** and **resets state** between testcases (logout, release interfaces, free contexts).

---

### Kernel & driver fuzzing, sanely

Drivers expose **Device Objects** with IOCTLs. A basic user-mode harness can open the device and fuzz the `DeviceIoControl` input buffer. Safety nets:

* Enable **Driver Verifier** for the target driver: Special Pool, Pool Tracking, I/O Verification.
* Use **VM snapshotting** and **KD** (kernel debugger) to catch bugchecks and auto-restart.
* Start with **read-only** IOCTLs; identify buffer sizes and method types (`METHOD_NEITHER`, etc.) before going aggressive.

Kernel fuzzing is rewarding but **expensive**—gate it behind clear goals and time boxes.

---

### Crash triage pipeline that holds up

You will collect **many** crashes; most are dupes. A minimal pipeline:

1. **Catch & dump**: on crash, emit a **minidump** (`MiniDumpWriteDump`) or use **WER LocalDumps**/ProcDump.
2. **Bucket**: (exception code, faulting IP, module, top 5 frames) → bucket ID.
3. **Minimize**: run a reducer (delta-debugging) per bucket to shrink inputs.
4. **Prioritize**: memory write > read > null deref; kernel > PPL > system service > low-priv GUI.
5. **Document**: repro steps, environment, mitigations observed; copy VAD maps and WinDbg `!analyze -v` output.

This lets exploit dev cherry-pick and defenders fix systematically.

---

## Example-first: practical mini-harnesses

### File parser harness with PageHeap + AppVerifier

```powershell
# Enable PageHeap & AppVerifier for target.exe (lab VM only)
gflags /p /enable target.exe /full
# Or AppVerifier
appverif -enable Heaps Exceptions Handles -for target.exe
```

```c
// A stand-alone launcher that runs the target EXE with one testcase per run.
// Good for black-box fuzzing when in-process harnessing is impossible.
#include <windows.h>
#include <stdio.h>

int wmain(int argc, wchar_t** argv) {
    if (argc != 3) { wprintf(L"usage: launch target.exe testcase\n"); return 1; }
    wchar_t cmd[MAX_PATH*4];
    _snwprintf_s(cmd, _countof(cmd), _TRUNCATE, L"\"%s\" \"%s\"", argv[1], argv[2]);

    STARTUPINFOW si = { sizeof(si) };
    PROCESS_INFORMATION pi;
    if (!CreateProcessW(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) return 2;

    WaitForSingleObject(pi.hProcess, 8000); // timeout per run
    DWORD code = 0; GetExitCodeProcess(pi.hProcess, &code);
    CloseHandle(pi.hThread); CloseHandle(pi.hProcess);
    return (code==0 || code==259) ? 0 : 3;
}
```

*Use:* black-box fuzzers spawn this launcher with mutated files. PageHeap/AppVerifier turns UB into crashes that WER or ProcDump can capture.

---

### RPC fuzzer skeleton

```c
// Minimal RPC driver (stateful): bind once, fuzz opnum calls.
// Compile MIDL stubs separately (not shown).
#include <windows.h>
#include <rpc.h>
#pragma comment(lib, "Rpcrt4.lib")

RPC_BINDING_HANDLE h = NULL;
void rpc_init() {
    RPC_WSTR str = (RPC_WSTR)L"ncacn_np:\\\\localhost\\pipe\\MyPipe";
    RPC_STATUS s = RpcBindingFromStringBindingW(str, &h);
    // adjust security/QOS as required
}

void fuzz_call(uint32_t opnum, const uint8_t* buf, size_t len) {
    RPC_MESSAGE msg = {0};
    // Build a manual NDR buffer or call generated stub with fuzzed fields.
    // For brevity, assume a generated proxy function MyOp(h, fuzz_struct)
}

int main() {
    rpc_init();
    // Persistent loop reading fuzzed frames ([opnum][len][bytes...]) from stdin
    // Similar to the file harness, with VEH and timeouts.
}
```

*Idea:* **stateful** orchestration (connect → Auth → Call A → Call B) unlocks code paths unreachable by single-call fuzzing.

---

### Basic IOCTL fuzzer (user mode against a driver)

```c
#include <windows.h>
#include <stdio.h>

int main() {
    HANDLE h = CreateFileW(L"\\\\.\\MyDevice", GENERIC_READ|GENERIC_WRITE,
                           0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (h == INVALID_HANDLE_VALUE) return 1;

    BYTE inbuf[4096], outbuf[4096];
    DWORD bytes = 0;
    for (;;) {
        // read testcase from stdin: [ioctl:4][size:4][data...]
        DWORD ioctl, size;
        if (!ReadFile(GetStdHandle(STDIN_FILENO), &ioctl, 4, &bytes, NULL)) break;
        ReadFile(GetStdHandle(STDIN_FILENO), &size, 4, &bytes, NULL);
        ReadFile(GetStdHandle(STDIN_FILENO), inbuf, size, &bytes, NULL);

        DeviceIoControl(h, ioctl, inbuf, size, outbuf, sizeof(outbuf), &bytes, NULL);
    }
    CloseHandle(h);
    return 0;
}
```

*Safety:* run with **Driver Verifier** on the target driver and take frequent VM snapshots. Start with known `IOCTL_` constants and valid sizes; escalate to fuzzing the control code bits only after mapping the API.

---

### Crash capture with minidumps (reliable repro)

```c
// On crash, create a .dmp next to the testcase (link DbgHelp)
#include <windows.h>
#include <dbghelp.h>
#pragma comment(lib, "Dbghelp.lib")

LONG WINAPI DumpFilter(EXCEPTION_POINTERS* ep)
{
    HANDLE h = CreateFileW(L"crash.dmp", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0);
    MINIDUMP_EXCEPTION_INFORMATION mei = { GetCurrentThreadId(), ep, TRUE };
    MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), h, MiniDumpWithDataSegs|MiniDumpWithIndirectlyReferencedMemory, &mei, 0, 0);
    CloseHandle(h);
    return EXCEPTION_EXECUTE_HANDLER;
}
```

*Why:* first-fault minidumps + symbolized `!analyze -v` turn “crashed” into *actionable*.

---

### Why this matters for exploitation / anti-exploit / malware analysis

Fuzzing is how you **scale** vulnerability discovery across Windows’ diverse surfaces; exploit dev is how you turn a crash into a **primitive** and then into an **impact** under modern mitigations. Attackers need harnesses that keep crashing deterministically and reach **deep states**; defenders need pipelines that **bucket**, **minimize**, and **explain** crashes (is it reachable remotely? does DEP/CFG/CET stop it?). Mastery here shortens the cycle from “bug” to either **credible exploit path** or **confident fix/mitigation** recommendation.

## APIs and functions

* `DeviceIoControl` — send IOCTLs to drivers; core of user-mode driver fuzzing.
* `RpcBindingFromStringBinding` / `RpcBindingSetAuthInfoEx` — establish RPC bindings and authentication before calling fuzzed opnums.
* `CoCreateInstance` / `IDispatch::Invoke` — instantiate and drive COM objects for stateful method fuzzing.
* `AddVectoredExceptionHandler` / `SetUnhandledExceptionFilter` — install exception fences so the harness survives crashes.
* `MiniDumpWriteDump` — emit minidumps for reliable crash triage and symbolized analysis.
* `RtlSetHeapInformation` / `HeapSetInformation` — enable heap integrity checks; pairs well with PageHeap.
* `CreateProcessW` / `WaitForSingleObject` — black-box fuzzing orchestration with per-run timeouts.
* `EtwEventWrite` (consumer side via `Get-WinEvent`/ETW API) — observe system effects (process/image/file) while replaying repros.

## Pitfalls, detection notes, and anti-analysis gotchas

* **No reset between testcases**: persistent harnesses must **reset global state** or leak allocations/handles; otherwise coverage and crashes degrade.
* **Timeout roulette**: per-iteration timeouts should be tight but fair; log *timeouts* separately—many hang bugs hide behind “testcase stuck.”
* **ASLR/CFG/CET noise**: for *triage*, you may disable CFG/CET in lab VMs to expose raw bugs; for *exploitability*, re-enable and document constraints.
* **Locale & encoding**: Unicode/UTF-8 vs OEM code pages shift parsers; pin `SetThreadLocale`/`SetConsoleCP` for determinism.
* **WOW64 confusion**: fuzzing an x86 target in an x64 host means **different DLLs and calling conventions**; attach the correct debugger, symbol path, and pageheap bitness.
* **Kernel deadlocks**: IOCTL fuzzing can hang the box; run under **VM with KD** and use **Driver Verifier** to fail-fast.
* **Corpus bloat**: without minimization you’ll drown; schedule regular **cmin** and **tmin** passes.
* **“Crashed ≠ exploitable”**: null derefs in low-priv sandboxes rarely matter; prioritize **write-primitive** and **UAF** buckets.

## Cross-references

* Turning a crash into control flow belongs in **Buffer Overflows** and **Use-After-Free & Type Confusion**.
* Building protection-flipping or syscall chains after a crash is in **ROP & JOP** and **Shellcoding**.
* For Windows memory layout, permissions, and VAD forensics, see **Memory & Virtual Address Space** and **DEP / NX / W^X**.
* For call-target constraints while triaging indirect-control crashes, see **Compiler & Hardware CFI: CFG, CET (Shadow Stack/IBT)**.
* For RPC/ALPC/COM background that informs harness design, see **IPC (ALPC, RPC, COM, Pipes)**.

## Glossary

* **Harness**: small program that exposes a target function to the fuzzer with deterministic setup/teardown.
* **Coverage**: metric of which edges or blocks were executed; used to prefer testcases that explore new code.
* **Persistent mode**: single process loops over many inputs, reducing start-up overhead and stabilizing instrumentation.
* **PageHeap**: heap instrumentation that detects overruns and UAFs by isolating allocations and using guard pages.
* **AppVerifier**: runtime checks (heaps, handles, locks) that convert UB into reliable crashes.
* **Bucket**: grouping of crashes by signature (exception + stack) to deduplicate findings.
* **Minidump**: compact memory snapshot at crash time for offline analysis.
* **IOCTL**: control code-based interface to kernel drivers via `DeviceIoControl`.
* **Stateful fuzzing**: generating sequences of valid operations to reach deep code paths (RPC/COM/protocols).
* **Grammar fuzzing**: generating structurally valid inputs from a formal specification.

## Key takeaways

* Good fuzzing on Windows is **harness-first**: stable, persistent loops with exception fences and deterministic state.
* Combine **coverage** with **sanitizers/verifiers** to turn silent UB into triage-friendly crashes.
* Favor **stateful** and **grammar-aware** approaches for RPC/COM/IOCTL—bytes alone rarely reach the deepest logic.
* Build a **crash pipeline** (dump → bucket → minimize → prioritize) so exploit dev time goes to the right bugs.
* Keep labs **VM-isolated**; kernel fuzzing demands snapshots, KD, and Driver Verifier to avoid host pain.
* Exploitability depends on **primitive + policy**; always retest under DEP/ASLR/CFG/CET and document the constraints for the handoff.
